// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test, console} from "forge-std/Test.sol";
import {Payments} from "../src/Payments.sol";
import {MockFeeOnTransferToken} from "./mocks/MockFeeOnTransferToken.sol";
import {PaymentsTestHelpers} from "./helpers/PaymentsTestHelpers.sol";
import {BaseTestHelper} from "./helpers/BaseTestHelper.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract FeeOnTransferVulnerabilityTest is Test, BaseTestHelper {
    PaymentsTestHelpers helper;
    Payments payments;
    MockFeeOnTransferToken feeToken;
    
    uint256 internal constant INITIAL_BALANCE = 10000 ether;
    uint256 internal constant DEPOSIT_AMOUNT = 1000 ether;
    uint256 internal constant FEE_PERCENTAGE = 200; // 2% fee
    
    function setUp() public {
        // Create test helpers and setup environment
        helper = new PaymentsTestHelpers();
        helper.setupStandardTestEnvironment();
        payments = helper.payments();
        
        // Create fee-on-transfer token with 2% fee
        feeToken = new MockFeeOnTransferToken("FeeToken", "FEE", FEE_PERCENTAGE);
        
        // Mint tokens to users
        feeToken.mint(USER1, INITIAL_BALANCE);
        feeToken.mint(USER2, INITIAL_BALANCE);
        
        // Approve payments contract
        vm.prank(USER1);
        feeToken.approve(address(payments), type(uint256).max);
        
        vm.prank(USER2);
        feeToken.approve(address(payments), type(uint256).max);
    }
    
    function testFeeOnTransferVulnerabilityBasic() public {
        // Record initial balances
        uint256 contractBalanceBefore = feeToken.balanceOf(address(payments));
        uint256 user1BalanceBefore = feeToken.balanceOf(USER1);
        
        // User1 deposits 1000 tokens, but due to 2% fee, only 980 actually reach the contract
        vm.prank(USER1);
        payments.deposit(address(feeToken), USER1, DEPOSIT_AMOUNT);
        
        // Check actual token balance vs recorded balance
        uint256 contractBalanceAfter = feeToken.balanceOf(address(payments));
        uint256 actualTokensReceived = contractBalanceAfter - contractBalanceBefore;
        uint256 expectedTokensReceived = DEPOSIT_AMOUNT - (DEPOSIT_AMOUNT * FEE_PERCENTAGE / 10000);
        
        // The contract actually received less due to fee
        assertEq(actualTokensReceived, expectedTokensReceived, "Contract received expected amount after fee");
        assertLt(actualTokensReceived, DEPOSIT_AMOUNT, "Contract received less than deposit amount");
        
        // The payments contract also knows it does not have the full amount
        (,uint256 recordedFunds,,) = payments.getAccountInfoIfSettled(address(feeToken), USER1);
        assertEq(recordedFunds, expectedTokensReceived, "Contract recorded full deposit amount");
    }
}