// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test, console} from "forge-std/Test.sol";
import {Payments} from "../src/Payments.sol";
import {MockFeeOnTransferToken} from "./mocks/MockFeeOnTransferToken.sol";
import {PaymentsTestHelpers} from "./helpers/PaymentsTestHelpers.sol";
import {BaseTestHelper} from "./helpers/BaseTestHelper.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract FeeOnTransferVulnerabilityTest is Test, BaseTestHelper {
    PaymentsTestHelpers helper;
    Payments payments;
    MockFeeOnTransferToken feeToken;
    
    uint256 internal constant INITIAL_BALANCE = 10000 ether;
    uint256 internal constant DEPOSIT_AMOUNT = 1000 ether;
    uint256 internal constant FEE_PERCENTAGE = 200; // 2% fee
    
    function setUp() public {
        // Create test helpers and setup environment
        helper = new PaymentsTestHelpers();
        helper.setupStandardTestEnvironment();
        payments = helper.payments();
        
        // Create fee-on-transfer token with 2% fee
        feeToken = new MockFeeOnTransferToken("FeeToken", "FEE", FEE_PERCENTAGE);
        
        // Mint tokens to users
        feeToken.mint(USER1, INITIAL_BALANCE);
        feeToken.mint(USER2, INITIAL_BALANCE);
        
        // Approve payments contract
        vm.prank(USER1);
        feeToken.approve(address(payments), type(uint256).max);
        
        vm.prank(USER2);
        feeToken.approve(address(payments), type(uint256).max);
    }
    
    function testFeeOnTransferVulnerabilityBasic() public {
        // Record initial balances
        uint256 contractBalanceBefore = feeToken.balanceOf(address(payments));
        uint256 user1BalanceBefore = feeToken.balanceOf(USER1);
        
        // User1 deposits 1000 tokens, but due to 2% fee, only 980 actually reach the contract
        vm.prank(USER1);
        payments.deposit(address(feeToken), USER1, DEPOSIT_AMOUNT);
        
        // Check actual token balance vs recorded balance
        uint256 contractBalanceAfter = feeToken.balanceOf(address(payments));
        uint256 actualTokensReceived = contractBalanceAfter - contractBalanceBefore;
        uint256 expectedTokensReceived = DEPOSIT_AMOUNT - (DEPOSIT_AMOUNT * FEE_PERCENTAGE / 10000);
        
        // The contract actually received less due to fee
        assertEq(actualTokensReceived, expectedTokensReceived, "Contract received expected amount after fee");
        assertLt(actualTokensReceived, DEPOSIT_AMOUNT, "Contract received less than deposit amount");
        
        // But the payments contract thinks it has the full amount
        (,uint256 recordedFunds,,) = payments.getAccountInfoIfSettled(address(feeToken), USER1);
        assertEq(recordedFunds, DEPOSIT_AMOUNT, "Contract recorded full deposit amount");
        
        // This creates a discrepancy
        assertGt(recordedFunds, actualTokensReceived, "Recorded funds exceed actual tokens");
        
        console.log("Deposit amount:", DEPOSIT_AMOUNT);
        console.log("Actual tokens received:", actualTokensReceived);
        console.log("Recorded balance:", recordedFunds);
        console.log("Discrepancy:", recordedFunds - actualTokensReceived);
    }
    
    function testFeeOnTransferVulnerabilityWithdrawFailure() public {
        // User1 and User2 both deposit the same amount
        vm.prank(USER1);
        payments.deposit(address(feeToken), USER1, DEPOSIT_AMOUNT);
        
        vm.prank(USER2);
        payments.deposit(address(feeToken), USER2, DEPOSIT_AMOUNT);
        
        // Both users have the same recorded balance
        (,uint256 user1Funds,,) = payments.getAccountInfoIfSettled(address(feeToken), USER1);
        (,uint256 user2Funds,,) = payments.getAccountInfoIfSettled(address(feeToken), USER2);
        
        assertEq(user1Funds, DEPOSIT_AMOUNT, "User1 has recorded deposit amount");
        assertEq(user2Funds, DEPOSIT_AMOUNT, "User2 has recorded deposit amount");
        
        // But the contract doesn't have enough tokens for both withdrawals
        uint256 contractBalance = feeToken.balanceOf(address(payments));
        uint256 totalRecordedFunds = user1Funds + user2Funds;
        
        assertLt(contractBalance, totalRecordedFunds, "Contract has less tokens than recorded funds");
        
        // First user can withdraw (stealing from second user)
        vm.prank(USER1);
        payments.withdraw(address(feeToken), DEPOSIT_AMOUNT);
        
        // Second user's withdrawal will fail
        vm.prank(USER2);
        vm.expectRevert(); // Will revert due to insufficient contract balance
        payments.withdraw(address(feeToken), DEPOSIT_AMOUNT);
        
        console.log("Contract balance:", contractBalance);
        console.log("Total recorded funds:", totalRecordedFunds);
        console.log("Shortfall:", totalRecordedFunds - contractBalance);
    }
    
    function testFeeOnTransferVulnerabilityWithMultipleUsers() public {
        uint256 numUsers = 10;
        address[] memory users = new address[](numUsers);
        
        // Create multiple users and have them deposit
        for (uint256 i = 0; i < numUsers; i++) {
            users[i] = address(uint160(0x1000 + i));
            feeToken.mint(users[i], INITIAL_BALANCE);
            
            vm.prank(users[i]);
            feeToken.approve(address(payments), type(uint256).max);
            
            vm.prank(users[i]);
            payments.deposit(address(feeToken), users[i], DEPOSIT_AMOUNT);
        }
        
        // Calculate total recorded vs actual
        uint256 totalRecorded = 0;
        for (uint256 i = 0; i < numUsers; i++) {
            (,uint256 funds,,) = payments.getAccountInfoIfSettled(address(feeToken), users[i]);
            totalRecorded += funds;
        }
        
        uint256 actualContractBalance = feeToken.balanceOf(address(payments));
        
        console.log("Number of users:", numUsers);
        console.log("Total recorded funds:", totalRecorded);
        console.log("Actual contract balance:", actualContractBalance);
        console.log("Total shortfall:", totalRecorded - actualContractBalance);
        
        // The shortfall scales with the number of users
        assertLt(actualContractBalance, totalRecorded, "Contract insolvent");
        
        // First few users can withdraw, draining the contract
        uint256 successfulWithdrawals = 0;
        for (uint256 i = 0; i < numUsers; i++) {
            vm.prank(users[i]);
            try payments.withdraw(address(feeToken), DEPOSIT_AMOUNT) {
                successfulWithdrawals++;
            } catch {
                break;
            }
        }
        
        console.log("Successful withdrawals:", successfulWithdrawals);
        console.log("Failed withdrawals:", numUsers - successfulWithdrawals);
        
        assertLt(successfulWithdrawals, numUsers, "Not all users could withdraw");
    }
}